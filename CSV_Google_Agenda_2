import os
import pandas as pd
from datetime import datetime
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow

# Autorisations Google Calendar
SCOPES = ["https://www.googleapis.com/auth/calendar"]

def authenticate_google():
    """Authentifie l'utilisateur et renvoie un service Google Calendar."""
    creds = None
    if os.path.exists("token.json"):
        creds = Credentials.from_authorized_user_file("token.json", SCOPES)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file("credentials.json", SCOPES)
            creds = flow.run_local_server(port=0)
        with open("token.json", "w") as token:
            token.write(creds.to_json())

    return build("calendar", "v3", credentials=creds)

def convert_to_datetime(date_str, time_str):
    """Convertit une date et une heure en objet datetime."""
    datetime_str = f"{date_str} {time_str}"
    return datetime.strptime(datetime_str, "%Y-%m-%d %H:%M")  # Adapter au format de tes données

def sanitize_csv_id(input_str):
    """Génère un identifiant unique nettoyé."""
    allowed = set("abcdefghijklmnopqrstuvwxyz0123456789_")
    result = input_str.replace(" ", "_").lower()
    return ''.join(c for c in result if c in allowed)

def fetch_existing_events(service):
    """Charge tous les événements existants avec leur csv_id pour limiter les requêtes."""
    events_result = service.events().list(
        calendarId='primary',
        maxResults=1000,  # Adapter selon le nombre d'événements attendus
        singleEvents=True
    ).execute()

    existing_events = {}
    for event in events_result.get('items', []):
        csv_id = event.get('extendedProperties', {}).get('private', {}).get('csv_id')
        if csv_id:
            existing_events[csv_id] = event  # Stocke l'événement existant par son ID unique

    return existing_events

def sync_events(service, df):
    """Optimise la mise à jour et création d'événements en limitant les requêtes."""
    room_colors = { #associer des couleurs aux salles dans google calendar 
        "Salle UT2J sans ordi": 1,  # Couleur rouge
        "UT2J GS027": 2,  # Couleur bleue
        "UT2J GS021": 3,  # Couleur verte
        "1003-Langue": 4,  # Couleur jaune
        "Salle ENSAT sans ordi" : 5,
        "703 (projet) ou alternance (entreprise)" : 6,
        "UT2J GS028" : 7,
    }

    
    existing_events = fetch_existing_events(service)  # Récupération en une seule requête
    events_to_create = []
    events_to_update = []
    events_to_delete = []

    for _, row in df.iterrows():
        raw_id = f"{row['Date']}_{row['Start Time']}_{row['Subject']}"
        csv_id = sanitize_csv_id(raw_id)
        
        start_datetime = convert_to_datetime(row['Date'], row['Start Time'])
        end_datetime = convert_to_datetime(row['Date'], row['End Time'])

        # Récupère la couleur associée à la salle, ou utilise une couleur par défaut
        location = row['Location']
        color_id = room_colors.get(location, 5)  # Par défaut, utilise la couleur 5 si la salle n'est pas dans le dictionnaire

        event_body = {
            'summary': row['Subject'],
            'location': location,
            'description': row['Description'],
            'start': {'dateTime': start_datetime.isoformat(), 'timeZone': 'Europe/Paris'},
            'end': {'dateTime': end_datetime.isoformat(), 'timeZone': 'Europe/Paris'},
            'extendedProperties': {'private': {'csv_id': csv_id}},
            'colorId': color_id  # Ajoute l'identifiant de couleur
        }

        if csv_id in existing_events:
            existing_event = existing_events[csv_id]
            differences = []
            if existing_event.get('summary', '') != row['Subject']:
                differences.append('summary')
            if existing_event.get('location', '') != location:
                differences.append('location')
            if existing_event.get('description', '') != row['Description']:
                differences.append('description')
            if existing_event.get('start', {}).get('dateTime', '') != start_datetime.isoformat():
                differences.append('start time')
            if existing_event.get('end', {}).get('dateTime', '') != end_datetime.isoformat():
                differences.append('end time')

            if differences:
                event_body['id'] = existing_event['id']  # Nécessaire pour la mise à jour en batch
                events_to_update.append(event_body)
        else:
            events_to_create.append(event_body)

    # Suppression des événements obsolètes
    existing_csv_ids = set(existing_events.keys())
    new_csv_ids = set(sanitize_csv_id(f"{row['Date']}_{row['Start Time']}_{row['Subject']}") for _, row in df.iterrows())
    obsolete_ids = existing_csv_ids - new_csv_ids
    for obsolete_id in obsolete_ids:
        events_to_delete.append(existing_events[obsolete_id]['id'])

    print(f"Création : {len(events_to_create)} | Mise à jour : {len(events_to_update)} | Suppression : {len(events_to_delete)}")

    batch = service.new_batch_http_request()
    for event in events_to_create:
        batch.add(service.events().insert(calendarId='primary', body=event))
    for event in events_to_update:
        batch.add(service.events().update(calendarId='primary', eventId=event['id'], body=event))
    for event_id in events_to_delete:
        batch.add(service.events().delete(calendarId='primary', eventId=event_id))
    
    batch.execute()  # Envoie toutes les requêtes en une seule fois

def main():
    service = authenticate_google()
    
    file_path = "C:/Users/loure/CNUM/CNUM_Synchronisation-de-l-agenda-SIGMA/output.csv"  
    df = pd.read_csv(file_path, sep=';')
    df.columns = df.columns.str.strip()  # Nettoie les colonnes
    
    sync_events(service, df)

if __name__ == "__main__":
    main()
